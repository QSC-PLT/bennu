{
  "name": "seshet",
  "version": "0.1.0",
  "description": "Functional memoization Utility",
  "keywords": [
    "memoization",
    "functional"
  ],
  "author": {
    "name": "Matt Bierner"
  },
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "git://github.com/mattbierner/seshet.git"
  },
  "main": "dist_node/seshet.js",
  "directories": {
    "lib": "dist_node"
  },
  "files": [
    "dist_node/",
    "lib",
    "test"
  ],
  "dependencies": {},
  "devDependencies": {
    "nodeunit": "0.8.x"
  },
  "scripts": {
    "test": "node test.js"
  },
  "readme": "Seshet\n======\n\nJavascript Functional Memorization Utility\n\n\n## About\nSeshat defines a set of operations for working with a two dimensional\ndata structure for use with memoization. One use case is memoizing\nthe results of computations in sequence, especially for parsing. The exposed\ninterfaces are all functional-style.\n\nIn most cases, Seshat has good access and update performance by using a self\nbalancing tree. The tree can also be pruned to discard unreachable values.\n\n\n# Example\n\nCalculating the Fibonacci sequence is the classic example of why memorization\nmatters. Although not the best application of Seshat, this demonstration implements\nthe Fibonacci sequence using Seshat.\n\n### Basic Algorithm\n\nThe basic logic for calculating Fibonacci number `n` is:\n\n    var fib = \\n ->\n        (n < 2 ? n\n            fib(n - 1) + fib(n -2));\n\nWritten using continuations for clearer translation:\n\n    var fib = \\n, k ->\n        (n < 2 ?\n            k(n)\n            fib(n - 1, \\x ->\n                fib(n - 2, \\y ->\n                    k(x + y))));\n\nThe problem with this approach is that `fib(n - 1)` and `fib(n - 2)` are\nrecalculated on every call, even when the calculation has been performed before.\nMemoization stores past results in a table to provide constant time lookup.\nIn this problem, only the previous two values need to be stored.\n\n### Basic Memoization\n\nSeshat operates on an memoization data structure, so `fib` is rewritten to take the\nopaque memoization table as an argument. The memo table is immutable, and needs\nto be threaded though the continuations.\n\nVales are stored using two dimensional keys. The first part of the key is used\nfor storing the value in a tree and the second part for looking up a specific\ninstance of the value on a node.  In the Fibonacci function, only one dimensional\nstorage is needed. The first part of the key will be the\nFibonacci number, and the second will always be zero.\n\nUpdating the `fib` function to take advantage of Seshat, before entering the\nFibonacci logic, the memo table is checked. If a result is found, it is\nreturned right away. Otherwise, the calculation is performed and the result is stored:\n\n    var fib = \\n, m, k -> {\n        var found = seshat.lookup(m, x, 0);\n        if (found !== null)\n            return k(found, m);\n        return (n < 2 ?\n            k(n, seshat.update(m, n, 0, n)) :\n            fib(n - 1, m, \\x, m ->\n                fib(n - 2, m, \\y, m ->\n                    k(x + y, seshat.update(m, n, 0, x + y)))));\n    };\n\nNow large Fibonacci numbers can be calculated. A key ordering function `compareInt`\nis defined for the keys of the memoization table. On the first call of `fib`,\na new, empty memoer is created.\n\n    var compareInt = \\x, y ->  x - y;\n    \n    // JS nums round this from the real result\n    fib(100, seshat.create(compareInt), \\x, m -> x); // 354224848179262000000\n\n\n### Pruning\nBy passing in a continuation that returns the memoization table,\nthis table can be inspected (This is for demonstration purposes only,\nthe table should always be treated as an opaque data structure):\n\n    var m = fib(100, seshat.create(compareInt), \\_, m -> m);\n    \n    var count = \\root ->\n        (!root ? 0 :\n            1 + count(root.left) + count(root.right));\n    \n    count(m.root); // 101 with values from [0 .. 100]\n\nAlthough 101 entries are stored, only the last two results in the calculations are ever\nused. Numbers before `n - 2` are unreachable. The unreachable entries can be pruned\nto reduce the size of the tree:\n\n    var fib = \\n, m, k -> {\n        var found = seshat.lookup(m, x, 0);\n        if (found !== null)\n            return k(found, m);\n        return (n < 2 ?\n            k(n, seshat.update(m, n, 0, n)) :\n            fib(n - 1, m, \\x, m ->\n                fib(n - 2, m, \\y, m ->\n                    k(x + y, seshat.prune(seshat.update(m, n, 0, x + y), n - 1)))));\n    };\n    \n    var m = fib(100, seshat.create(compareInt), \\_, m -> m);\n    count(m.root); // 2 with values for [99, 100]\n\nThe prune uses `n - 1` as the lower bound because the lower bound is inclusive\nand only values for `n` and `n - 1` are needed. Although not particularly beneficial\nin this case, pruning can reduce memory usage and improving access performance. \n\n### Hof\nSeshat is not designed for direct use. This simplified example demonstrates\nusing Seshat for memoization of a monadic Fibonacci calculator:\n\n    // Basic Operations\n    var ret = \\x -> \\m, k -> k(x, m);\n    var bind = \\c, f -> \\m, k -> c(m, \\x, m -> f(x)(m, k));\n    var next = \\p, c -> bind(p, \\() -> c);\n    \n    var modifyM = \\f -> \\m, k -> let x = f(m) in k(x, x);\n    var getM = modifyM(\\m -> m);\n    \n    // Memoer Operations\n    var update = \\key, val ->\n        next(\n            modifyM(\\m -> seshat.update(m, key, 0, val)),\n            ret(val));\n    \n    var lookup = \\key, fallback ->\n        bind(getM, \\m -> \n            let found = seshat.lookup(m, key, 0) in\n                (found !== null ? ret(found) : fallback));\n    \n    // Fibonacci\n    var fib = \\n ->\n        (n < 2 ? ret(n) :\n            lookup(n, bind(fib(n - 1), \\x ->\n                bind(fib(n - 2), \\y ->\n                    update(n, x + y)))));\n    \n    fib(100)(seshat.create(compareInt), \\x -> x)); //354224848179262000000\n\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mattbierner/seshet/issues"
  },
  "homepage": "https://github.com/mattbierner/seshet",
  "_id": "seshet@0.1.0",
  "_from": "seshet@0.1.x"
}
