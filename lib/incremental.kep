/**
 * @fileOverview Parsers for use specifically with text.
 */
package (
// Operations
    provide,
    provideString,
    finish,
    
// Creation
    parseState,
    parse,
    
    runManyState,
    runManyStream,
    runMany)
with
    import 'parse/parse' {
        always,
        bind,
        getParserState,
        exec,
        Memoer,
        next,
        optional,
        ParserState,
        Position,
        runState,
        trampoline},
    import 'nu/stream' stream{'end': NIL, isEmpty, first, rest}
in {

/* Records
 ******************************************************************************/
var Request = function(chunk, state, k) {
    this.chunk = chunk;
    this.state = state;
    this.k = k;
};

var Resumable = function(done, state, k, chunks) {
    this.done = done;
    this.state = state;
    this.k = k;
    this.chunks = chunks;
};

Resumable.prototype.addChunk = \c ->
    new Resumable(
        this.done,
        this.state,
        this.k,
        this.chunks.concat(c));

Resumable.prototype.hasChunk = \c ->
    (c < this.chunks.length);

Resumable.prototype.getChunk = \c ->
    this.chunks[c];

/* IncrementalState
 ******************************************************************************/
/**
 * State for an incremental parser.
 * 
 * Forwards all operations to an inner state.
 * 
 * @param chunk Identifier for the chunk the state is currently operating on.
 * @param state Inner parser state.
 */
var IncrementalState = function(chunk, state) {
    this.chunk = chunk;
    this.state = state;
};

Object.defineProperties(IncrementalState, {
    'input': {
        'get': \() -> this.state.input
    },
    'position': {
        'get': \() -> this.state.position
    },
    'userState': {
        'get': \() -> this.state.userState
    }
});

IncrementalState.prototype.eq = \other ->
    other && other.chunk === this.chunk && other.state.eq(other.state);

IncrementalState.prototype.isEmpty = \() ->
    this.state.isEmpty();

IncrementalState.prototype.first = \() ->
    this.state.first();

IncrementalState.prototype.next = \x -> {
    if (!this._next) {
        var chunk = this.chunk;
        var self = this;
        
        if (isEmpty(rest(this.state.input))) {
            return bind(next(self.state.next(x), getParserState), \s ->
                \_, m, cok ->
                    new Request(
                        chunk + 1,
                        s,
                        \i -> cok(x, new IncrementalState(chunk + 1, s.setInput(i)), m)));
        }
        
        this._next = next(
            this.state.next(x),
            bind(getParserState, \innerState ->
                let state = new IncrementalState(chunk, innerState) in
                    \_, m, cok ->
                        cok(x, state, m)));
    }
    return this._next;
};

IncrementalState.prototype.setInput = \input ->
    new IncrementalState(
        this.chunk,
        this.state.setInput(input));

IncrementalState.prototype.setPosition = \position ->
    new IncrementalState(
        this.chunk,
        this.state.setPosition(position));

IncrementalState.prototype.setUserState = \userState ->
    new IncrementalState(
        this.chunk,
        this.state.setUserState(userState));

/* Operations
 ******************************************************************************/
/**
 * Feed a new chunk of input to an incremental parser.
 * 
 * @param r Resumable state
 * @param c Nu stream of input for chunk.
 * 
 * @return New resumable state for parser after input has been recieved.
 */
provide = \r, c -> {
    if (r.done)
        return r;
    
    var r2 = r.addChunk(c);
    var result = trampoline(r2.k(r2.state.setInput(c)));
    while (result instanceof Request) {
        if (!r2.hasChunk(result.chunk))
            return new Resumable(
                false,
                result.state,
                \x -> result.k(x.input),
                r2.chunks);
        result = trampoline(result.k(r2.getChunk(result.chunk)));
    }
    return result;
};

/**
 * Feed an array-like to an incremental parser.
 * 
 * @param Resumable state.
 * @param input Array like object of input.
 */
provideString = \r, input ->
    provide(r, stream.from(input));

finish = \r ->
    !r.done ?
        finish(trampoline(r.k(r.state))) :
        r.k(r.state);

/* Incremental Creation
 ******************************************************************************/
/** 
 * Run a given parser with a given state.
 * 
 * @param p Parser to run.
 * @param state IncrementalState to run parser against.
 * 
 * @return Result from the parser.
 */
parseState = \p, state ->
    new Resumable(
        false,
        new IncrementalState(0, state),
        \s -> let
            ok = \x, s -> new Resumable(true, s, \ -> x),
            err =\x, s -> new Resumable(true, s, \ -> { throw x; })
        in
            exec(p, s, Memoer.empty, ok, err, ok, err),
        []);

/**
 * Run parser 'p' against an input string.
 * 
 * @param p Parser to run.
 * @param input Array-like object of characters to run the parser against.
 * @param [ud] User data.

 * @return Result from the parser.
 */
parse = \p, ud ->
    parseState(
        p,
        new ParserState(
            NIL,
            Position.initial,
            ud));

/* Run Many
 ******************************************************************************/
/**
 * Run parser 'p' zero or more times to produce a lazy stream of results.
 * 
 * Similar in operation to the 'many' parser, but is not a
 * combinatorial parser.
 * 
 * Result may be an infinite stream.
 * 
 * @param p Parser to run zero or more times.
 * @param state State to run parser against.
 * 
 * @return Lazy stream of results.
 */
runManyState = \p, state -> let
    manyP = optional(NIL,
        bind(p, \x, state, m ->
            always(stream.memoStream(x, (runState, manyP, state, m)))))
in
    runState(manyP, state);

/**
 * Run parser 'p' zero or more times to produce a lazy stream or results.
 * 
 * Supplies own state.
 * 
 * @param p Parser to run.
 * @param s Nu style stream supporting first and rest.
 * @param [ud] User data.
 *
 * @see runManyState
 */
runManyStream = \p, s, ud ->
    runManyState(p, new ParserState(s, Position.initial, ud));

/**
 * Run parser 'p' zero or more times against an input string to produce a lazy
 * stream or results.
 * 
 * @param p Parser to run.
 * @param input Array-like object of characters to run the parser against.
 * @param [ud] User data.
 *
 * @see runManyStream
 */
runMany = \p, input, ud ->
    runManyStream(p, stream.from(input), ud);

}