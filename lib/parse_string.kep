/**
 * @fileOverview Parsers for use specifically with strings.
 */
define(['parse/parse',
        'nu/stream'],
function(parse,
        stream) {
"use strict";

/* Prototypes
 ******************************************************************************/
var map = Array.prototype.map;
var reduce = Array.prototype.reduce;
var reduceRight = Array.prototype.reduceRight;

var regExpTest = RegExp.prototype.test;

/* Helpers
 ******************************************************************************/
var stringEq = (a, b) -> a.valueOf() === b.valueOf();

var expectError = msg ->
    (pos, tok) ->
        new parse.ExpectError(pos, msg, (tok === null ? "end of input": tok));

/* Parsers
 ******************************************************************************/
/**
 * Parser that consumes a given character. 
 * 
 * Unboxes string Objects
 * 
 * @param c The char to consume.
 */
var charParser = c ->
    parse.token(stringEq.bind(undefined, c), expectError(c));

/**
 * Parser that consumes a given string.
 * 
 * Unlike 'parse.string', this parses all or nothing. Either it matches the string
 * or it fails at the starting location.
 * 
 * @param {String} s String to consume.
 */
var stringParser = (function(){
    var impl = (original, remaining, found, pos) ->
        (remaining.length === 0 ?
           parse.always(original) :
           parse.bind(
               parse.token(
                   stringEq.bind(undefined, remaining[0]),
                   (_, tok) -> new parse.ExpectError(pos, original, (tok === null ? found : found + tok))),
               x -> impl(original, remaining.slice(1), found + x, pos)));
    
    return s ->
        parse.bind(
            parse.getPosition(),
            pos ->
                parse.attempt(impl(s, s, "", pos)));
}());

/**
 * Parser that builds a parse trie from an array of strings.
 */
var trieParser = (function(){
    var wordReduce = (parent, l) -> (parent[l] = (parent[l] || {}));
    
    var wordsReduce = function(trie, word) {
        var node = reduce.call(word, wordReduce, trie);
        node[''] = null;
        return trie;
    };
    
    var makeTrie = words -> words.reduce(wordsReduce, {});
    
    var _trie = function(trie, prefix) {
        var choices = [];
        Object.keys(trie).forEach(n -> {
            if (n.length === 1) {
                choices.push(parse.next(
                    charParser(n),
                    _trie(trie[n], prefix + n)));
            }
        });
        
        if (trie.hasOwnProperty('')) {
            choices.push(parse.always(prefix));
        }
        
        return parse.choice.apply(undefined, choices);
    };
    
    return nodes -> parse.attempt(_trie(makeTrie(nodes), ''));
}());

/**
 * Parser that consumes any character.
 */
var anyCharParser = parse.token(regExpTest.bind(/^.$/), expectError("any character"));

/**
 * Parser that consumes any letter character.
 */
var letterParser = parse.token(regExpTest.bind(/^[a-z]$/i), expectError("any letter character"));

/**
 * Parser that consumes any space character.
 */
var spaceParser = parse.token(regExpTest.bind(/^\s$/i), expectError("any space character"));

/**
 * Parser that consumes any number character.
 */
var digitParser = parse.token(regExpTest.bind(/^[0-9]$/i), expectError("any digit character"));

/* Export
 ******************************************************************************/
return {
// Parsers
    'character': charParser,
    'string': stringParser,
    'trie': trieParser,
    
    'anyChar': anyCharParser,
    'letter': letterParser,
    'space': spaceParser,
    'digit': digitParser
};

});