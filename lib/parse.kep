/**
 * @fileOverview Combinatorial Parsers for JavaScript.
 * 
 * Unless otherwise noted, parses do not support backtracking by default.
 */
package (
    ParserError,
    
    ParseError,
    MultipleError,
    UnknownError,
    UnexpectError,
    ExpectError,
    
// Objects
    ParserState,
    Position,
    
// Rec
    rec,
    
// Parser Definition
    Parser,
    RecParser,
    
// Parsers
    always,
    never,
    bind,
    eof,
    
    extract,
    getParserState,
    setParserState,
    modifyParserState,
    
    getState,
    setState,
    modifyState,
    
    getInput,
    setInput,
    
    getPosition,
    setPosition,
    
    fail,
    attempt,
    lookahead,
    
    next,
    sequencea,
    sequence,
    either,
    choicea,
    choice,
    optional,
    expected,
    
    eager,
    binds,
    cons,
    append,
    enumerationa,
    enumeration,
    many,
    many1,

    token,
    anyToken,

    memo,
    
// Running
    exec,
    
    perform,
    
    runState,
    runStream,
    run,
    
    runManyState,
    runManyStream,
    runMany,
    
    testState,
    testStream,
    test)
with
    import 'nu/stream' stream{'end': NIL, first, isEmpty, rest},
    import 'seshat' seshat
{

var map = Function.prototype.call.bind(Array.prototype.map);
var reduceRight = Function.prototype.call.bind(Array.prototype.reduceRight);

var curry = \f, ... -> f.bind.apply(f, arguments);

var identity = \x -> x;

var constant = \x -> \() -> x;

var throwConstant = \err -> \() -> { throw err; };

var uniqueParserId = Math.random;

/* Continuation
 ******************************************************************************/
var cont = \f, args -> {
    var c = [f, args];
    c._next = true;
    return c;
};

var trampoline = \f -> {
    var value = f;
    while (value && value._next)
        value = value[0].apply(undefined, value[1]);
    return value;
};

/* Memoization
 ******************************************************************************/
/**
 * Structure used for memoization of parser results.
 * 
 * The memoer uses the concept of a window, a lower bound position, to designate
 * reachable results in the stream. Memoized results for positions outside of the
 * window will be automatically pruned when possible.
 */
var Memoer = function(memoer, frames) {
    this.memoer = memoer;
    this.frames = frames;
};

/**
 * Empty Memoer.
 */
Memoer.empty = new Memoer(
    seshat.create(
        \x, y -> x.compare(y),
        \x, y -> (x.id === y.id && (x.state === y.state || (x.state && x.state.eq(y.state))))),
    []);

/**
 * Push a new window onto the stack.
 */
Memoer.pushWindow = \m, lower ->
    new Memoer(
        m.memoer,
        [lower].concat(m.frames));

/**
 * Pop the top most window.
 * 
 * Prunes table when possible.
 */
Memoer.popWindow = \m ->
    new Memoer(
       (m.frames.length === 1 ?
            seshat.prune(m.memoer, m.frames[0]) :
            m.memoer),
        m.frames.slice(1));

/**
 * Lookup memoized result at `pos` for parser `id`.
 * 
 * Return null if none.
 */
Memoer.lookup = \m, pos, id ->
    seshat.lookup(m.memoer, pos, id);

/**
 * Update the memoization table to store `val` for result at `pos` from parser
 * `id`.
 */
Memoer.update = \m, pos, id, val ->
    new Memoer(
        seshat.update(m.memoer, pos, id, val),
        m.frames);

/* Records
 ******************************************************************************/
// Position
////////////////////////////////////////
/**
 * Position in the input.
 * 
 * Simply tracks the index in the input.
 */
Position = function(i) {
    this.index = i;
};

/**
 * Initial position in a stream.
 */
Position.initial = new Position(0);

Position.prototype.toString = \() -> '' + this.index;

/**
 * Advanced the position based on a consumed character.
 * 
 * @param tok Token that was consumed.
 * 
 * @returns Position after 'tok'.
 */
Position.prototype.increment = \tok -> new Position(this.index + 1);

/**
 * Compares two positions.
 * 
 * @returns Number less than, equal to, or greater than zero if this position is
 *   less than, equal to, or greater than 'pos'.
 */
Position.prototype.compare = \pos -> (this.index - pos.index);

// ParserState
////////////////////////////////////////
/**
 * Object used to track a Parser's state.
 * 
 * @param input Input to the parser.
 * @param position Current position of head of input.
 * @param [userState] Object that users can thread through parsers.
 */
ParserState = function(input, position, userState) {
    this.input = input;
    this.position = position;
    this.userState = userState;
};

/**
 * Compares two states for memoization.
 * 
 * This is a part of the seshat id lookup process so the correct position has
 * already been found when this is called.
 */
ParserState.prototype.eq = \other ->
    other && this.input === other.input && this.userState === other.userState;

/**
 * Is the state's input empty.
 */
ParserState.prototype.isEmpty = \() ->
    isEmpty(this.input);

/**
 * Get the first item of the input.
 */
ParserState.prototype.first = \() ->
    first(this.input);

/**
 * Get next state object for a given consumed token.
 * 
 * @param tok Token consumed.
 * 
 * @returns New input state for next item in input.
 */
ParserState.prototype.next = \x -> {
    if (!this._next) {
        var s = new ParserState(
            rest(this.input),
            this.position.increment(x),
            this.userState);
        this._next = \_, m, cok -> cok(x, s, m);
    }
    return this._next;
};

/**
 * Create a new state with input.
 * 
 * @param input New input.
 */
ParserState.prototype.setInput = \input ->
    new ParserState(input, this.position, this.userState);

/**
 * Create a new state with position.
 * 
 * @param position New position.
 */
ParserState.prototype.setPosition = \position ->
    new ParserState(this.input, position, this.userState);

/**
 * Create a new state with userState.
 * 
 * @param userState New user state.
 */
ParserState.prototype.setUserState = \userState ->
    new ParserState(this.input, this.position, userState);

/* Errors
 ******************************************************************************/
/**
 * @constructor
 * @implements {Error}
 * 
 * Base Error for an error with the parsers themselves.
 */
ParserError = function(msg) {
    this.message = msg;
};
ParserError.prototype = new Error();
ParserError.prototype.constructor = ParserError;
ParserError.prototype.name = 'ParserError';

/**
 * @constructor
 * @implements {Error}
 * 
 * Base Error for an error encountered during parsing.
 * 
 * @param position Position of error.
 * @param [msg] Error message.
 */
ParseError = function(position, msg) {
    this.position = position;
    this._msg = msg;
};
ParseError.prototype = new Error;
ParseError.prototype.constructor = ParseError;
ParseError.prototype.name = 'ParseError';

/**
 * @HACK: Chrome's Error.prototype.toString seems broken for a `message`
 *    getter.
 */
ParseError.prototype.toString = \() ->
    this.name + ": " + this.message;

Object.defineProperties(ParseError.prototype, {
    'message': {
        'configurable': true,
        'get': \() ->
            "At position:" + this.position + " " + this.errorMessage
    },
    'errorMessage': {
        'configurable': true,
        'get': \() ->
            (this._msg === undefined ? "" : this._msg)
    }
});

/**
 * @constructor
 * @implements {ParseError}
 * Merges zero or more ParseErrors into a single ParseError.
 * 
 * @params position Position of errors.
 * @params [errors] Array like object containing zero or more ParseErrors.
 */
MultipleError = function(position, errors) {
    ParseError.call(this, position);
    this.errors = (errors || []);
};
MultipleError.prototype = new ParseError();
MultipleError.prototype.constructor = MultipleError;
MultipleError.prototype.name = 'MultipleError';

Object.defineProperty(MultipleError.prototype, 'errorMessage', {
    'get': \() ->
        "[" + map(this.errors, \x -> x.message).join(", ") + "]"
});

/**
 * @constructor
 * @implements {MultipleError}
 * Specific type of multiple errors used in internally for choices.
 * 
 * Defers merging errors until actually needed.
 */
var ChoiceError = function(position, pErr, qErr) {
    ParseError.call(this, position);
    this._pErr = pErr;
    this._qErr = qErr;
};
ChoiceError.prototype = new MultipleError();
ChoiceError.prototype.constructor = MultipleError;
ChoiceError.prototype.name = 'ChoiceError';

Object.defineProperty(ChoiceError.prototype, 'errors', {
    'get': \() ->
        [this._pErr].concat(this._qErr.errors)
});

/**
 * @constructor
 * @implements {ParseError}
 * 
 * @param position Position of error.
 */
UnknownError = function(position) {
    ParseError.call(this, position);
};
UnknownError.prototype = new ParseError();
UnknownError.prototype.constructor = UnknownError;
UnknownError.prototype.name = 'UnknownError';

Object.defineProperty(UnknownError.prototype, 'errorMessage', {
    'value': "unknown error"
});

/**
 * @constructor
 * @implements {ParseError}
 * 
 * @param position Position of error.
 * @param unexpected Found value.
 */
UnexpectError = function(position, unexpected) {
    ParseError.call(this, position);
    this.unexpected = unexpected;
};
UnexpectError.prototype = new ParseError();
UnexpectError.prototype.constructor = UnexpectError;
UnexpectError.prototype.name = 'UnexpectError';

Object.defineProperty(UnexpectError.prototype, 'errorMessage', {
    'get': \() ->
        "Unexpected:" + this.unexpected
});

/**
 * @constructor
 * @implements {ParseError}
 * 
 * @param position Position of error.
 * @oaram expected Expected value.
 * @param [found] Found value.
 */
ExpectError = function(position, expected, found) {
    ParseError.call(this, position);
    this.expected = expected;
    this.found = found;
};
ExpectError.prototype = new ParseError();
ExpectError.prototype.constructor = ExpectError;
ExpectError.prototype.name = "ExpectError";

Object.defineProperty(ExpectError.prototype, 'errorMessage', {
    'get': \() ->
        "Expected:" + this.expected + (this.found ?
            " Found:" + this.found :
            "")
});

/* Rec
 ******************************************************************************/
/**
 * Creates a parser using a factory function to allow self references.
 * 
 * For example, using a traditional definition the self reference to 'bs'
 * evaluates to undefined:
 * 
 *    var bs = parse.either(parse.character('b'), bs) => parse.either(parse.character('b'), undefined)
 * 
 * Using rec, we fix this.
 * 
 *     var bs = rec(function(self) {
 *         return parse.either(parse.character('b'), self);
 *     });
 * 
 * @param def Factory function that is passed a reference to the parser being
 *     defined and returns the parser.
 * 
 * @return A parser.
 */
rec = \def -> {
    var value = def(\... -> value.apply(this, arguments));
    return value;
};

/* Parser definition
 ******************************************************************************/
/**
 * Create a named parser.
 * 
 * Attaches a name for debugging and a unique id for memoization.
 * 
 * If parser is already named, wraps the parser in a new named parser.
 * 
 * @param {string} name Human readable display name to give the Parser. Used for
 *     identifying a parser for debugging.
 * @param impl Implementation of the parser itself, not the parser's constructor.
 *
 * @return 
 */
Parser = \name, impl ->
    (impl.hasOwnProperty('parserId') ? 
        Parser(name, \... -> impl.apply(this, arguments)) :
        Object.defineProperties(impl, {
            'displayName': {
                'value': name,
                'writable': false
            },
            'parserId': {
                'value': uniqueParserId(),
                'writable': false
            }
        }));

/**
 * Create a recursively defined parser.
 * 
 * @param body The body of the parser.
 */
RecParser = \name, body -> Parser(name, rec(body));

/* Parsers
 ******************************************************************************/
// Base Parsers
////////////////////////////////////////
/**
 * Parser that always succeeds with a given value and consumes no input.
 * 
 * @param x Value to succeed with.
 */
always = \x ->
    function ALWAYS_PARSER(state, m, cok, cerr, eok /*, _*/) {
        return eok(x, state, m);
    };

/**
 * Parser that always fails and consumes no input.
 * 
 * @param x Value to fail with.
 */
never = \x ->
    function NEVER_PARSER(state, m, cok, cerr, eok, eerr) {
        return eerr(x, state, m);
    };

/**
 * Parser that parses 'p', passing the results to function 'f' which returns a
 * parser 'q' that continues the computation.
 * 
 * @param p Parser to run, passing results to f.
 * @param f Function called with result from 'p' and returns parser 'q'.
 */
bind = \p, f ->
    function BIND_PARSER(state, m, cok, cerr, eok, eerr) {
        return cont(p, [state, m,
            \x, state, m -> cont(f(x, state, m), [state, m, cok, cerr, cok, cerr]),
            cerr,
            \x, state, m -> cont(f(x, state, m), [state, m, cok, cerr, eok, eerr]),
            eerr]);
    };

// State Interaction Parsers
////////////////////////////////////////
/**
 * Parser that modifies the current parser state using function 'f'.
 * 
 *  @param {function(ParserState): *} f Function that transforms that current state.
 */
modifyParserState = \f ->
    function MODIFY_PARSER_STATE(state, m, cok, cerr, eok /*, _*/) {
        var newState = f(state);
        return eok(newState, newState, m);
    };

/**
 * Parser that returns the current state.
 */
getParserState = Parser('Get Parser State',
    modifyParserState(identity));

/**
 * Parser that sets current parser state to 's'.
 * 
 * @param s New parser state.
 */
setParserState = \s ->
    modifyParserState(constant(s));

/**
 * Parser that extracts information from the Parser's current state.
 * 
 * @param {function(Object): *} f Function that extracts information from a 
 *     given state object.
 */
extract = \f ->
    function EXTRACT(state, m, cok, cerr, eok /*, _*/) {
        return eok(f(state), state, m);
    };

/**
 * Parser that modifies the current user state using function 'f'.
 * 
 *  @param {function(ParserState): *} f Function that transforms that current user state.
 */
modifyState = \f ->
    modifyParserState(\state -> state.setUserState(f(state.userState)));

/**
 * Parser that returns the current user state.
 */
getState = Parser('Get State',
    extract(\s -> s.userState));

/**
 * Parser that sets current user parser state to 's'.
 * 
 * @param s New user parser state.
 */
setState = \s ->
    modifyState(constant(s));

/**
 * Parser that gets the current position.
 */
getPosition =  Parser('Get Position',
    extract(\s -> s.position));

/**
 * Parser that sets the current position
 */
setPosition = \position ->
    modifyParserState(\s -> s.setPosition(position));

/**
  *Parser that gets the current input.
 */
getInput =  Parser('Get Input',
    extract(\s -> s.input));

/**
 * Parser that sets the current input.
 */
setInput = \input ->
    modifyParserState(\s -> s.setInput(input));

//
////////////////////////////////////////
var _fail = \e ->
    bind(getPosition, \pos -> never(e(pos)));

/**
 * Parser that always fails with an error and consumes no input.
 * 
 * @param {String} [msg] Message for error.
 */
fail = \msg ->
    let e = (msg ? ParseError : UnknownError) in
        _fail(\pos -> new e(pos, msg));

/**
 * Parser that matches end of input.
 */
eof = let
    end = always(NIL)
in
    Parser('EOF',
        bind(getParserState, \s ->
        (s.isEmpty() ?
            end :
            _fail(\pos -> new ExpectError(pos, "end of input", s.first())))));

/**
 * Parser that attempts parser `p`. Upon failure, never consumes any input.
 */
attempt = \p ->
    function ATTEMPT_PARSER(state, m, cok, cerr, eok, eerr) {
        var peerr = \x, s, m -> eerr(x, s, Memoer.popWindow(m));
        return cont(p, [state, Memoer.pushWindow(m, state.position),
            \x, s, m -> cok(x, s, Memoer.popWindow(m)),
            peerr,
            \x, s, m -> eok(x, s, Memoer.popWindow(m)),
            peerr]);
    };

/**
 * Parser that consumes no input but returns what was parsed.
 */
lookahead = \p ->
    function LOOKAHEAD_PARSER(state, m, cok, cerr, eok, eerr) {
        var ok = \item, _, m -> eok(item, state, m);
        return cont(p, [state, m, ok, cerr, eok, eerr]);
    };

// Combinitorial Parsers
////////////////////////////////////////
/**
 * Parser that parses 'p', then 'q'. Return the 'q' value.
 */
next = \p, q ->
    bind(p, constant(q));

/**
 * Consume a finite sequence of 1 or more parsers, returning result from last.
 * 
 * This may partially fail if any parser fails in the sequence. Wrap in attempt
 * to prevent partial failures.
 * 
 * @param arr Array of parsers to consume.
 */
sequencea = let reducer = \p, q -> next(q, p) in
    \arr -> reduceRight(arr, reducer);

/**
 * Same as `sequencea` but gets parsers from arguments instead of array.
 */
sequence = \... -> sequencea(arguments);

var _either = \e ->
    \p, q ->
        function EITHER_PARSER(state{position}, m, cok, cerr, eok, eerr) {
            var peerr = \errFromP, _, mFromP -> {
                var qeerr = \errFromQ, _, mFromQ ->
                    eerr(e(position, errFromP, errFromQ), state, mFromQ);
                return cont(q, [state, mFromP, cok, cerr, eok, qeerr]);
            };
            return cont(p, [state, m, cok, cerr, eok, peerr]);
        };

/**
 * Parser that attempts p or q. If p succeeds, returns its value. Else, tries
 * to parse q.
 */
either = _either(\pos, pErr, qErr -> new MultipleError(pos, [pErr, qErr]));

/**
 * Parser that attempts a number of parsers in order and returns
 * the value of the first one that succeeds.
 * 
 * Throws a ParserError if called with no arguments.
 * 
 * @param arr Array of parsers to attempt.
 */
choicea = let
    either = _either(\pos, pErr, qErr -> new ChoiceError(pos, pErr, qErr)),
    reducer = \p, c -> either(c, p),
    end = bind(getPosition, \pos -> never(new MultipleError(pos, [])))
in
    \arr -> {
        if (!arr.length)
            throw new ParserError("choice called no parsers");
        return reduceRight(arr, reducer, end);
    };

/**
 * Same as choice but gets parsers from arguments.
 */
choice = \... -> choicea(arguments);

/**
 * Consume 'p' either zero or one time.
 * 
 * @param x Default value to return.
 * @param p Parser to consume zero or one times.
 * 
 * @return Result of 'p' or default value.
 */
optional = \x, p ->
    either(p, always(x));

/**
 * Parser that parses 'p' but if 'p' fails without consuming input, produces
 * an ExpectError with 'msg'.
 * 
 * @param expect Expected value. 
 * @param p Parser to attempt.
 */
expected = \expect, p ->
    function EXPECTED_PARSER(state, m, cok, cerr, eok, eerr) {
        return p(state, m, cok, cerr, eok, \(x, state, m) -> eerr(new ExpectError(state.position, expect), state, m));
    };

// Iterative Parsers
////////////////////////////////////////
var _end = always(NIL);

var _optionalValueParser = curry(optional, NIL);

var _joinParser = \joiner ->
    \p1, p2 ->
        bind(p1, \v1 ->
            bind(p2, \v2 ->
                always(joiner(v1, v2))));

/**
 * Parser that takes stream results from 'p' and eagerly turns them into a
 * regular array.
 */
eager = let toArray = \x -> always(stream.toArray(x)) in
    \p -> bind(p, toArray);

/**
 * Same as bind but calls apply on 'f' using stream results of 'p'.
 */
binds = \p, f ->
    bind(eager(p), \x ->
        f.apply(undefined, x));

/**
 * Parser that cons the value result of 'valueParser' onto the stream result
 * of 'streamParser'.
 * 
 * @param valueParser Parser that returns a value.
 * @param streamParser Parser that returns a stream.
 */
cons = _joinParser(stream.cons);

/**
 * Parser that joins the results of two iterative Parsers
 */
append = _joinParser(stream.append);

/**
 * Consume a finite sequence of parsers, returning the results as a stream.
 * 
 * @param arr Array of parsers to consume.
 */
enumerationa = let reducer = \p, q -> cons(q, p) in
    \arr -> reduceRight(arr, reducer, _end);

/**
 * Same as `enumerationa` but gets parsers from arguments.
 */
enumeration = \... -> enumerationa(arguments);

/**
 * Consume 'p' zero or more times.
 * 
 * Will throw an error when 'p' succeeds without consuming. As this is an error
 * with the parser itself, this event breaks out of parsing.
 * 
 * @param p Parser to consume zero or more times.
 */
many = let
    manyError = throwConstant(
        new ParserError("Many parser applied to a parser that accepts an empty string"))
in
    function MANY_PARSER(p) {
        var safeP = \state, m, cok, cerr, eok, eerr ->
            cont(p, [state, m, cok, cerr, manyError, eerr]);
        return rec(\self -> _optionalValueParser(cons(safeP, self)));
    };

/**
 * Consume 'p' 1 or more times.
 * 
 * @param p Parser to consume.
 */
many1 = \p -> cons(p, many(p));

// Token Parsers
////////////////////////////////////////
/**
 * Parser that consumes a single item from the head of the input if consume is
 * true. Fails to consume input if consume is false or input is empty.
 * 
 * @param {function(string): boolean} consume Function that tests if a
 *     character should be consumed.
 * @param {function(object): Error} [errMsg] Optional function that returns
 *    the error when consume fails. Passed the state position and tested token.
 */
token = let
    defaultErr = \pos, tok ->
        new UnexpectError(pos, (tok === null ? "end of input" : tok))
in
    \consume, onErr -> {
        var errorHandler = (onErr || defaultErr);
        return function TOKEN_PARSER(state{position}, m, cok, cerr, eok, eerr) {
            if (state.isEmpty()) {
                return eerr(errorHandler(position, null), state, m);
            } else {
                var tok = state.first();
                return (consume(tok) ?
                    state.next(tok)(state, m, cok, cerr, eok, eerr) :
                    eerr(errorHandler(position, tok), state, m));
            }
        };
    };

/**
 * Parser that consumes any token.
 */
anyToken = Parser('Any Token',
    token(constant(true)));

/* Memo Parsers
 ******************************************************************************/
/**
 * Parser that uses memoized result for 'p' or parse 'p' and stores result in memo table.
 * 
 * Memoization is based on equal states, not equal inputs.
 */
memo = \p -> let
    id = (p.parserId || uniqueParserId())
in
    \state{position}, m, cok, cerr, eok, eerr -> {
        var key = {'id': id, 'state': state};
        var entry = Memoer.lookup(m, position, key);
        if (entry)
            return cont(entry, [state, m, cok, cerr, eok, eerr]);
        
        return cont(p, [state, m,
            \x, pstate, pm ->
                cok(x, pstate,
                    Memoer.update(pm, position, key, \(_, m, cok /*, cerr, eok, eerr*/) -> cok(x, pstate, m))),
            \x, pstate, pm ->
                cerr(x, pstate,
                    Memoer.update(pm, position, key, \(_, m, cok, cerr /*, eok, eerr*/) -> cerr(x, pstate, m))),
            \x, pstate, pm ->
                eok(x, pstate,
                    Memoer.update(pm, position, key, \(_, m, cok, cerr, eok /*, eerr*/) -> eok(x, pstate, m))),
            \x, pstate, pm ->
                eerr(x, pstate,
                    Memoer.update(pm, position, key, \(_, m, cok, cerr, eok, eerr) -> eerr(x, pstate, m)))]);
    };

/* Running
 ******************************************************************************/
/**
 * Execute a given parser 'p', correctly extracting results.
 */
exec = \p, state, m, cok, cerr, eok, eerr ->
    trampoline(p(state, m, cok, cerr, eok, eerr))();

var _perform = \p, state, ok, err ->
    exec(p, state, Memoer.empty, ok, err, ok, err);

/**
 * Perform parser 'p' with state, returning result from callback 'ok' when 
 * successful and from 'err' on error.
 */
perform = \p, state, ok, err ->
    _perform(p, state,
        \x, state, m -> \() -> ok(x, state, m),
        \x, state, m -> \() -> err(x, state, m));

/**
 * Run a given parser with a given state.
 * 
 * @param p Parser to run.
 * @param state State to run parser against.
 * 
 * @return Result from the parser.
 */
runState = \p, state ->
    _perform(p, state, constant, throwConstant);

/**
 * Run parser 'p' against an input stream.
 * 
 * Supplies own state object.
 * 
 * @param p Parser to run.
 * @param s Nu style stream supporting first and rest.
 * @param [ud] User data.
 * 
 * @return Result from the parser.
 */
runStream = \p, s, ud ->
    runState(p, new ParserState(s, Position.initial, ud));

/**
 * Run parser 'p' against an input string.
 * 
 * @param p Parser to run.
 * @param input Array-like object of characters to run the parser against.
 * @param [ud] User data.

 * @return Result from the parser.
 */
run = \p, input, ud ->
    runStream(p, stream.from(input), ud);

/**
 * Run parser 'p' zero or more times to produce a lazy stream of results.
 * 
 * Similar in operation to the 'many' parser, but is not a
 * combinatorial parser.
 * 
 * Result may be an infinite stream.
 * 
 * @param p Parser to run zero or more times.
 * @param state State to run parser against.
 * 
 * @return Lazy stream of results.
 */
runManyState = \p, state -> {
    var manyP = _optionalValueParser(
        bind(p, \(x, state, m) ->
            always(stream.memoStream(x, curry(runState, manyP, state, m)))));
    return runState(manyP, state);
};

/**
 * Run parser 'p' zero or more times to produce a lazy stream or results.
 * 
 * Supplies own state.
 * 
 * @param p Parser to run.
 * @param s Nu style stream supporting first and rest.
 * @param [ud] User data.
 *
 * @see runManyState
 */
runManyStream = \p, s, ud ->
    runManyState(p, new ParserState(s, Position.initial, ud));

/**
 * Run parser 'p' zero or more times against an input string to produce a lazy
 * stream or results.
 * 
 * @param p Parser to run.
 * @param input Array-like object of characters to run the parser against.
 * @param [ud] User data.
 *
 * @see runManyStream
 */
runMany = \p, input, ud ->
    runManyStream(p, stream.from(input), ud);

/**
 * Tests parser 'p' with a given state.
 * 
 * @param p Parser to run.
 * @param state State to run parser against.
 *
 * @return Did the parser successfully run?
 */
testState = let
    ok = constant(constant(true)),
    err = constant(constant(false))
in
    \p, state -> _perform(p, state, ok, err);

 /**
 * Test parser 'p' against stream 's'.
 * 
 * @param p Parser to run.
 * @param s Nu style stream supporting first and rest.
 * @param [ud] User data.
 * 
 * @see testState
 */
testStream = \p, s, ud ->
    testState(p, new ParserState(s, Position.initial, ud));

/**
 * Test parser 'p' against 'input'.
 * 
 * @param p Parser to run.
 * @param input Array-like object of characters to run the parser against.
 * @param [ud] User data.
 *
 * @see testStream
 */
test = \p, input, ud ->
    testStream(p, stream.from(input), ud);

}