/**
 * @fileOverview Parsers for use specifically with text.
 */
package (
    provide,
    provideString,
    finish,
    parseState,
    parse)
with
    import 'parse/parse' {always, attempt, choicea,exec, ExpectError, Memoer, next, Parser, ParserState, Position, token},
    import 'nu/stream' stream{'end': NIL, isEmpty, first, rest}
in {

var trampoline = \f -> {
    var value = f;
    while (value && value._next)
        value = value[0].apply(undefined, value[1]);
    return value;
};

var Request = function(chunk, state, k) {
    this.chunk = chunk;
    this.state = state;
    this.k = k;
};

var Resumable = function(done, chunk, state, k, chunks) {
    this.done = done;
    this.chunk = chunk;
    this.state = state;
    this.k = k;
    this.chunks = chunks;
};

Resumable.prototype.addChunk = \c ->
    new Resumable(
        this.done,
        this.chunk + 1,
        this.state,
        this.k,
        this.chunks.concat(c));

// ParserState
////////////////////////////////////////
/**
 * Object used to track a Parser's state.
 * 
 * @param input Input to the parser.
 * @param position Current position of head of input.
 * @param [userState] Object that users can thread through parsers.
 */
var State = function(input, chunk, position, ud) {
    this.input = input;
    this.chunk = chunk;
    this.position = position;
    this.userState = ud;
};

/**
 * Compares two states for memoization.
 * 
 * This is a part of the seshat id lookup process so the correct position has
 * already been found when this is called.
 */
State.prototype.eq = \other ->
    other && this.input === other.input && this.userState === other.userState;

/**
 * Is the state's input empty.
 */
State.prototype.isEmpty = \() ->
    isEmpty(this.input);

/**
 * Get the first item of the input.
 */
State.prototype.first = \() ->
    first(this.input);

/**
 * Get next state object for a given consumed token.
 * 
 * @param tok Token consumed.
 * 
 * @returns New input state for next item in input.
 */
State.prototype.next = \x -> {
    if (!this._next) {
        var chunk = this.chunk;
        
        var s = new State(
            rest(this.input),
            chunk,
            this.position.increment(x),
            this.userState);
        
        if (isEmpty(rest(this.input))) {
            var s = new State(
                rest(this.input),
                chunk + 1,
                this.position.increment(x),
                this.userState);
            return \_, m, cok -> new Request(chunk + 1, s, \s -> cok(x, s, m));
        }
        
        this._next = \_, m, cok -> cok(x, s, m);
    }
    return this._next;
};

/**
 * Create a new state with input.
 * 
 * @param input New input.
 */
State.prototype.setInput = \input ->
    new State(input, this.chunk, this.position, this.userState);

/**
 * Create a new state with position.
 * 
 * @param position New position.
 */
State.prototype.setPosition = \position ->
    new State(this.input, this.chunk, position, this.userState);

/**
 * Create a new state with userState.
 * 
 * @param userState New user state.
 */
State.prototype.setUserState = \userState ->
    new State(this.input, this.chunk, this.position, userState);

/* Running
 ******************************************************************************/
provide = \r, c -> {
    if (r.done)
        return r;
    
    var r2 = r.addChunk(c);
    var result = trampoline(r2.k(r2.state.setInput(c)));
    while (result instanceof Request) {
        if (result.chunk >= r2.chunks.length)
            return new Resumable(
                false,
                r2.chunk,
                result.state,
                result.k,
                r2.chunks);
        result = trampoline(result.k(result.state.setInput(r2.chunks[result.chunk])));
    }
    return result;
};

provideString = \r, s ->
    provide(r, stream.from(s));

finish = \r ->
    !r.done ?
        finish(trampoline(r.k(r.state))) :
        r.k(r.state);

/** 
 * Run a given parser with a given state.
 * 
 * @param p Parser to run.
 * @param state State to run parser against.
 * 
 * @return Result from the parser.
 */
parseState = \p, state ->
    new Resumable(
        false,
        0,
        state,
        \s -> let
            ok = \x, s -> new Resumable(true, -1, s, \ -> x),
            err = \x, s -> new Resumable(true, -1, s, \ -> { throw x; })
        in
            exec(p, s, Memoer.empty, ok, err, ok, err),
        []);

/**
 * Run parser 'p' against an input string.
 * 
 * @param p Parser to run.
 * @param input Array-like object of characters to run the parser against.
 * @param [ud] User data.

 * @return Result from the parser.
 */
parse = \p, ud ->
    parseState(
        p,
        new State(
            NIL,
            0,
            Position.initial,
            ud));

}